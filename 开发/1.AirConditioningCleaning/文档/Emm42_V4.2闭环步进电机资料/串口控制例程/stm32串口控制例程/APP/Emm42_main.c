#include "Emm42_board.h"
#include "Emm42_delay.h"
#include "Emm42_usart.h"

__IO int32_t MotorPosition = 0; __IO float MotorAngle = 0.0f;

/**************************************************************
***	STM32和Emm42_V4.0步进闭环的接线：
		*	1. 要先根据说明书安装好Emm42_V4.0步进闭环驱动板到电机上
		*	2. Emm42_V4.0步进闭环驱动板的V+和Gnd接7~28V供电
		*	3. Emm42_V4.0闭环驱动板第一次上电，要先点击Cal选项进行编码器校准
		*	4. 确保闭环驱动屏幕上的Mode选项选择CR_UART模式
		*	5. STM32的PA9接Emm闭环驱动的RX引脚
		*	6. STM32的PA10接Emm闭环驱动的TX引脚
		* 7. STM32的Gnd接Emm闭环驱动的Gnd引脚

***	注意事项：
		* 1. 要先接好线再通电，不要带电拔插6P的端子插头！！！

***	如果你的STM32控制板是STM32最小系统，使用USB进行供电的话，注意上电顺序：
		*	上电时，先通闭环驱动板的7~28V供电，再通STM32控制板的USB供电，避免一些效应造成损坏！！！
		*	断电时，先断STM32控制板的USB供电，再断闭环驱动板的7~28V供电。
***************************************************************/
int main (void)
{
	uint8_t cmd[10] = {0}; uint16_t i = 0;

/**********************************************************
***	初始化板载外设
		*	1. 初始化NVIC中断优先级
		*	2. 使能GPIOA、AFIO、UART时钟
		*	3. 初始化UART
**********************************************************/
	Emm42_board_init();

/**********************************************************
***	延时1.2秒等待Emm闭环驱动板上电初始化完毕
**********************************************************/	
	Emm42_delay_ms(1200);

/**********************************************************
***	STM32串口发命令控制Emm_V4.0步进闭环驱动
**********************************************************/	
	while(1)
	{
/**********************************************************
***	发送命令
		* 串口位置控制命令格式：

	地址 0xFD  2字节方向+速度  加速度   3字节脉冲   CRC
	[0]  [1]     [2]  [3]       [4]   [5] [6] [7]  [8]

**********************************************************/	
		cmd[0] = 0x01;	/* 地址 */
		cmd[1] = 0xFD;	/* 功能码 */
		cmd[2] = 0x12;	/* 方向半字节 + 速度高半字节 */
		cmd[3] = 0xFF;	/* 速度字节,( (uint16_t)(cmd[2] & 0x0F) << 8 | (uint16_t)cmd[3] )组成速度 */
		cmd[4] = 0x40;	/* 加速度 */
		cmd[5] = 0x00;	/* 脉冲数高字节 */
		cmd[6] = 0x0C;	/* 脉冲数中字节 */
		cmd[7] = 0x80;	/* 脉冲数低字节 */
		cmd[8] = 0x6B;;	/* 固定校验字节 */
		
		/* 发送命令 */
		for(i=0; i < 9; i++) { usartSend(cmd[i]); }

		/*
			等待接收返回命令
				* Emm42_V4.0闭环接收到命令后将会返回命令：
						1.如果接收到命令是错误命令，则返回：01（地址） EE 6B（校验码）
						2.如果接收到命令是正确命令，则返回：01（地址） 02 6B（校验码）
						3.如果位置控制命令执行完成，则返回：01（地址） 9F 6B（校验码）
		*/
		rxReceiveCount = 0; while(rxFrameFlag == false); rxFrameFlag = false;

/**********************************************************
***	发送命令
		* 串口读取电机位置命令格式：

	地址  0x36  CRC
	[0]   [1]   [2]

**********************************************************/	
		cmd[0] = 0x01;	/* 地址 */
		cmd[1] = 0x36;	/* 功能码 */
		cmd[2] = 0x6B;	/* 固定校验字节 */
		
		/* 发送命令 */
		for(i=0; i < 3; i++) { usartSend(cmd[i]); }
		
		/* 等待接收返回数据 */
		rxReceiveCount = 0; while(rxFrameFlag == false);
		
		/* 校验地址 */
		if(rxBuffer[0] == cmd[0])
		{
			/* 拼接成电机位置 */
			MotorPosition = (int32_t)rxBuffer[1] << 24 | (int32_t)rxBuffer[2] << 16 | (int32_t)rxBuffer[3] << 8 | (int32_t)rxBuffer[4];
			
			/* 转换成角度单位 */
			MotorAngle = (float)( ( (int64_t)MotorPosition * (int64_t)225) / (int64_t)4096 ) / (float)10.0;
		}
		rxFrameFlag = false;
	}
}

